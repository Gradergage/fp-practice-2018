module Task3_3 where


newtype PSet a = PSet{ contains :: (a -> Bool) }

-- Реализуйте классы Monoid и Functor
-- Объясните в комментариях, почему они реализованы именно так

-- Для моноида:

-- Для осуществления этого, согласно сигнатуре,
-- PSet должен иметь нейтральное значение 
-- операция группировки с использованием логического ИЛИ и нейтрального значения False
-- обеспечивает соблюдение основного закона моноида, т. к
-- False || a === a || False === а
-- Либо же для логического И и нейтрального значения True
-- True && a === a && True === а

instance Semigroup (PSet t) where
    (<>) (PSet a) (PSet b) = PSet (\x -> a x || b x)

instance Monoid (PSet a) where
    mempty = PSet (\_ -> False) -- нейтральное значение моноида
-- таким образом для PSet выполняется a `mappend` mempty === mempty `mappend` a === a
    mappend = (<>)

-- для True и &&
newtype PSet' a = PSet'(a -> Bool)

instance Semigroup (PSet' t) where
    (<>) (PSet' a) (PSet' b) = PSet' (\x -> a x && b x)

instance Monoid (PSet' a) where
    mempty = PSet' (\_ -> True)
    mappend = (<>)




-- Что делает fmap? Он применяет функцию к фукнтору
-- и возвращает новый функтор. "Распаковывает" значение внутри функтора,
-- применяет к нему функцию и запаковывает обратно (1)
-- Грубо говоря функтором является объект, для которого определен fmap, например maybe.
-- Получается, что при подстановке в fmap PSet (a -> Bool),
-- мы должны получить следующую сигнатуру (a -> b) -> PSet a -> PSet b
-- а для того чтобы успешно вернуть PSet b, b должен представлять тип (a -> Bool),
-- для того чтобы условие (1) выполнялось, нам необходимо применять функцию f
-- к содержимому PSet. Функция f имеет сигнатуру (a -> b), это и будет конечным результатом,
-- на вход которому должен поступать тип a, а в итоге имеется bool,
-- который необходимо отобразить в b. (Bool -> b) (Ага! Вот оно! 
-- Вот тот тип, который и будет отвечать требованиям fmap)
-- Будет предпринята попытка запаковать реузльтат в новый функтор PSet (a -> bool).
-- Поэтому результат данной операции - ошибка
-- Если мы изменим отображение PSet на (Bool -> a)
-- То тогда операция (f . a) имеет смысл, на входе функция f будет получать тип a, который можно
-- отобразить в b
-- Итого мы имеем отображение PSet(a -> bool). После применения к нему отображения f (a -> b) мы получаем ошибку.
-- В данном случае, для PSet удовлетворительным будет contrmap :: (a -> b) -> f b -> f a (стрелочки поменялись)
-- тогда для этого композиция функций тоже изменится и станет a . f.
-- Грубо говоря получится вот такая вещь ((a -> b) -> bool), что полностью нас устраивает
-- Таким образом, ковариантного функтора, по определению чистой fmap (a -> b) -> PSet a -> PSet b не существует,
-- есть только контравариантный (a -> b) -> PSet b -> PSet a
class ContraFunctor f where
    contrmap :: (a -> b) -> f b -> f a

instance ContraFunctor PSet where
    contrmap f (PSet a) = PSet (a . f)


-- Если изменить изначальный тип на отображение Bool -> a,
-- то становится доступным ковариантный функтор с fmap (a -> b) -> PSet a -> PSet b, в котором стрелочки,
-- грубо говоря, не переворачиваются и остаются в исходном состоянии и удовлетворяют (1)
newtype СontraPSet a = СontraPSet (Bool -> a)

instance Functor СontraPSet where
    fmap f (СontraPSet a) = СontraPSet (f . a)




